<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>VeraCrypt工具 | Jane Blog System</title>
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../resources/styles.css">
</head>
<body>
    <div class="header">
        <a class="logo" href="../index.html"
           style="background: url(../resources/logo.svg); background-size: 100% 100%"></a>
        <div class="nav">
            <a href="../index.html">Home</a>
            <a href="../nav1-links.html">Links</a>
            <a href="../nav2-my-nav.html">My Nav Page</a>
        </div>
    </div>
    <div class="page-image" style="background: url(https://picsum.photos/2560/600) center; background-size: cover"></div>
    <div class="main article-page">
        <h1>VeraCrypt工具</h1>
        <div class="page-cate-date">
            <a href="../index.html#it">IT</a>
            · 2020-03-08
        </div>
        <p>记录一下TrueCrypt的替代品，VeraCrypt这个工具的一些使用要点。虽然说老百姓日常生活可能不太会用得到，但是这一类军用级别，加密度爆表的，能够保护隐私，知名度高，这么棒的一个工具，我觉得有必要记录一下，也许哪一天你可能会用的上。</p>
<!-- more -->
<h1>简单理解隐藏分区</h1>
<p>所谓隐藏分区就是，在一个加密盘(物理加密或者虚拟加密)里面再创建一个加密盘(内层隐藏分区)，最重要的文件一般都放在这里，这两个盘都分别有不同的口令和keyfiles，要注意<strong>当你打开其中一个则看不到另外一个</strong>。技术上来说，是拿外层的剩余空间来做内层隐藏分区的空间。</p>
<ol>
<li>只打开内层，输入内层的口令与keyfiles，进行读写操作。</li>
<li>只打开外层，进行读写操作，同时不对内层数据进行保护。只输入外层的口令，这么做有可能在读写的过程中破坏内层的数据。(受到威胁，可以考虑使用)</li>
<li>只打开外层，进行<strong>只读</strong>操作，同时对内层数据进行保护。除了输入外层口令的同时，在加载选项里勾选“只读”模式。</li>
<li>只打开外层，进行读写操作，同时对内层数据进行保护。需要分别输入外层和内层的口令。</li>
</ol>
<h1>物理加密和虚拟加密</h1>
<p><strong>推荐配合VeraCrypt加密卷“创建向导”来理解</strong></p>
<hr />
<h2>物理</h2>
<ol>
<li>所谓物理加密，就是对电脑上的某一个分区(包括操作系统所在的分区)，或者整个硬盘，用算法加密。</li>
<li>一些注重隐私的操作系统，例如Tails,Kodachi,都会建议将系统安装在U盘上，因此整个操作都在RAM下进行，一旦关机或拔出都不会留下一点痕迹，因此可以推断再怎么小心也难免会在ROM留下操作痕迹，所以要彻底地把信息的泄漏程度降到最低，最好是加密操作系统所在的分区或者整个硬盘。</li>
<li>备份则相对麻烦，需要折腾磁盘备份工具，例如Ghost。</li>
</ol>
<h2>虚拟</h2>
<ol>
<li>虚拟加密盘，其实就是创建一个文件，然后把文件挂载起来就可以使用了，在电脑看上去就好像“多出了一个硬盘”。</li>
<li>备份则相对方便，复制到某一个地方，就相当于完成了备份。</li>
<li>还有一个“双刃剑”的方面，就是虚拟加密盘里面，或者在盘的隐藏分区里面，放另一个虚拟加密盘，这样就实现了嵌套，大大增加破解的难度，理论上只要不超出加密盘的容量是可以放无数个，但是对使用者来说也是负担，要记住共放了多少个，每多放一个你就要记多一个口令或者keyfiles，也许那些对安全要求极高的人会考虑这种做法。</li>
</ol>
<h2>搭配网盘</h2>
<ol>
<li>注意，虚拟加密盘在挂载(mount)状态的时候，就会锁住对应的文件，无法对这个文件进行读写，很自然也无法同步到网盘，需要Umount才能同步。(注意，这里所说的无法读写是指文件，虚拟加密盘就是一个文件，不要以为是说加密盘里的数据无法读写)</li>
<li>注意，网盘提供商都不一样，所以，文件大小有可能超过网盘的‘单次文件上传容量上限’，解决的办法，要么是找文件分割工具处理，要么是换一个网盘，要么就是最开始别把虚拟加密盘创得那么大。</li>
<li>注意，这点其实是建议，不管本地的加密盘备份到云端网盘也好，备份到U盘或是移动硬盘之类的也好，每一次备份之前，都随意大量修改外层盘的文件，增加差异性，不然的话两个盘的口令与外层文件都一样，十分容易让人察觉出有隐藏分区的存在。</li>
<li>搭配网盘使用有以下3个优点：
<ol>
<li>保密性，例如对应以下两种情况，第1种，不管国内国外，网盘提供商的用户资料都有可能被窥探或者因为公司的安全漏洞而泄漏，又或者是被人盗取了网盘帐号，即使这样，网盘里面的加密盘文件还是处于加密状态的；第2种，某些网盘在上传文件的时候没有进行【加密传输协议】，如果有人对你网络流量‘嗅探’，就很有可能拿到同步的数据了。</li>
<li>复用性，万一出什么天灾人祸，或者某一天电脑硬盘坏了，都可以从网盘取回来。</li>
<li>降低对云端的依赖，如果平时有将本地的那份加密盘文件上传到网盘的习惯，即使哪一天网盘提供商倒闭了，因为本地那份还在，再另外找个新的网盘上传备份就解决了。
<em>关于一些网盘提供商的对比，wikipedia搜索comparison of online backup services</em></li>
</ol>
</li>
</ol>
<h2>更加隐私，可以考虑结合两者的优点</h2>
<p>虚拟加密盘放到物理加密盘里面，放到物理加密盘的隐藏分区效果则更好。把信息泄漏的程度降到最低的同时，在电脑里看上去也不会感觉有什么可疑的大文件，然后继续日常的操作，一样也不妨碍正常备份到云端。</p>
<h1>keyfiles</h1>
<ol>
<li>自选：keyfile的文件内容最好是杂乱无规律，选择一切能被压缩的文件，(BMP和WAV不能被压缩)，确保随机性足够大，最好是二进制文件，文件至少超过1KB。(误解：文件并不是越大越好，最多只提取keyfile开头1MB的内容进行处理)</li>
<li>它选：用VeraCrypt生成纯随机的keyfiles，优点是生成出来的质量非常合格，拥有足够高的随机性，缺点就是，如果没有备份而且又弄丢了，那加密盘就真的再也打不开了，因为这是世界上独一无二的keyfile。</li>
<li>只拿keyfiles当作口令，跟口令对比的好处就是不担心被穷举暴力破解，另外一个好处就是比长长的口令要好记，数量一般推荐5～10个；缺点，keyfiles不能用作加密系统分区。总结就是，即便keyfiles有它的优点，但是完全可以配合口令一起使用，使得安全性更高。</li>
</ol>
<h1>口令与密钥</h1>
<p>如果打算单纯使用口令来保护加密盘文件的话，奉劝自行做足功课，要设一个足够复杂度同时也方便自己记忆的口令也是很有学问。
<font color="#663300"><em>密钥分header key和master key，分别对应着加密盘的头部区和数据区，头部区存放着能解锁数据区的master key，以及一些有关数据区的元数据(metadata)，(理解起来，有点类似GPT分区的概念)，所以，口令和keyfiles通过散列运算生成的是头部区的密钥，然后用里面的主密钥(master key)通过算法解开数据区，最后才能对里面的文件进行读写等操作。(更多详情查阅TrueCrypt User Guide)</em></font></p>
<ol>
<li>首先，通过输入的口令和keyfiles，通过数学运算(哈希运算或者叫散列运算)，产生出密钥。之所以使用散列算法是因为：
<ol>
<li>可逆性：散列算法不可逆，加密算法则是可逆的，压缩算法也是可逆的。</li>
<li>确定性：比如两个数据算出来的散列值不同，则这两个数据一定不同；再比如，两个数据算出来的散列值一样，则这两个数据99.99%相同。(为什么达不到百分百相同，因为要骗过一些“基于散列值的完整性”校验，一些散列值是可以人为碰撞制造出来，一旦散列值对得上，就可以在校验蒙混过关，甚至可以对原数据偷天换日。所以为了要避免人为碰撞和随机碰撞，需要选择散列值的长度要大，而且是优秀知名的算法。拿其中一个散列算法举个例子，SHA512算法长度是512比特，最多可表示2的512次方种可能性，可以想象一下有多大)</li>
</ol>
</li>
<li>基于以上两点，因此一旦输错了口令或者keyfiles，肯定会产生出一个错误的密钥，错误的密钥自然无法对加密盘进行解密了。输入正确的口令之后，用生成的密钥再通过算法(例如AES算法)，对加密盘进行加密或者解密，最后就可以读写盘里的数据。<font color="#0000ff">根据你资料的敏感程度或者使用习惯，可自行权衡去选择“单重”、“双重”、“三重”，这3种其中一种的加密组合</font>
<font color="#663300"><em>(VeraCrypt支持对称加密算法，即用同一个密钥对明文或密文进行加密或者解密)</em></font></li>
<li><font color="#FF0000">澄清一点</font>：密码(口令)不参与加密盘的加密解密运算；密码只是通过不可逆的散列算法计算出密钥，密钥再通过可逆的加密算法对加密盘进行加密或解密操作。可以理解为，密码的作用是保护密钥。</li>
</ol>
<h1>盗取密钥</h1>
<ol>
<li>为了确保安全性，VeraCrypt是不会把加密盘的密钥存到ROM上，但是为了实时加密或解密，密钥必然会放到内存(RAM)中，如果内存数据不幸遭到攻击或者盗窃，攻击者则有可能从内存中分析出密钥。但是要拿到内存中的密钥有一个前提，就是加密盘尚未卸载(umount)，一旦umount之后VeraCrypt就会把处在内存中的密钥清空。另外要注意系统加密盘是无法umount的，只能靠正常关机来释放内存，而防止内存里的密钥被盗取。举个休眠攻击的场景，当系统休眠时，休眠(内存)文件会写到系统分区里，当以下3个条件同时满足就有可能通过分析休眠文件而拿到虚拟加密盘的主密钥，条件1，加密盘处于挂载状态，条件2，操作系统分区没有加密，条件3，攻击者通过一些办法拿到休眠文件。所以安全起见，1.平时不要轻易休眠，2.记得加密操作系统分区。</li>
<li>例如还有，cold boot attack，DMA attack，等等的盗取密钥的手法请自行了解。</li>
<li>再举个例子，通过替换BL(Boot Loader)盗取口令，如果选择加密系统分区或者硬盘，当系统被入侵，攻击者用一个假的BL替换VeraCrypt在引导扇区定制的BL，然后你在不知情的情况下输入了口令，口令就这么被盗取了。两个防范手段，1.查看BIOS是否支持硬盘锁功能，增加一个硬盘锁口令，多设一道防线；2.在U盘上使用系统，把一些隐私性高的linux系统装到U盘，因为此时系统分区处于U盘上，自然不依赖硬盘的引导扇区(BL)，少了一个可被攻击的点。</li>
</ol>
<h1>总结</h1>
<p>不管是口令，keyfiles，还是密钥，被盗的方式有千千万万种，无论工具再怎么好，也很考验使用者平时的安全意识。正如VeraCrypt一类的加密工具也不是万能，使用一个安全的操作系统非常重要，不然再强的加密工具也保护不了你的数据。</p>

    </div>
    <div class="footer">
        © <a href="mailto://pandolia@yeah.net">Pandolia</a>
        - <a target="_blank" href="https://jane.pandolia.net/">Jane</a>
        - <a target="_blank" href="https://alembic.darn.es/">Alembic</a>
        - 2020
    </div>
</body>
</html>